"""
This type stub file was generated by pyright.
"""

import os
import sys
import contextlib
import org.python.modules.posix.PosixModule as _os
from distutils.errors import DistutilsError

if sys.platform.startswith('java'):
    ...
else:
    _os = ...
_open = ...
@contextlib.contextmanager
def save_argv(repl=...): # -> Generator[List[str], None, None]:
    ...

@contextlib.contextmanager
def save_path(): # -> Generator[List[str], None, None]:
    ...

@contextlib.contextmanager
def override_temp(replacement): # -> Generator[None, None, None]:
    """
    Monkey-patch tempfile.tempdir with replacement, ensuring it exists
    """
    ...

@contextlib.contextmanager
def pushd(target): # -> Generator[str, None, None]:
    ...

class UnpickleableException(Exception):
    """
    An exception representing another Exception that could not be pickled.
    """
    @staticmethod
    def dump(type, exc): # -> tuple[bytes, bytes]:
        """
        Always return a dumped (pickled) type and exc. If exc can't be pickled,
        wrap it in UnpickleableException first.
        """
        ...
    


class ExceptionSaver:
    """
    A Context Manager that will save an exception, serialized, and restore it
    later.
    """
    def __enter__(self): # -> ExceptionSaver:
        ...
    
    def __exit__(self, type, exc, tb): # -> Literal[True] | None:
        ...
    
    def resume(self): # -> None:
        "restore and re-raise any exception"
        ...
    


@contextlib.contextmanager
def save_modules(): # -> Generator[Dict[str, ModuleType], None, None]:
    """
    Context in which imported modules are saved.

    Translates exceptions internal to the context into the equivalent exception
    outside the context.
    """
    ...

@contextlib.contextmanager
def save_pkg_resources_state(): # -> Generator[Unknown, None, None]:
    ...

@contextlib.contextmanager
def setup_context(setup_dir): # -> Generator[None, None, None]:
    ...

_MODULES_TO_HIDE = ...
def hide_setuptools(): # -> None:
    """
    Remove references to setuptools' modules from sys.modules to allow the
    invocation to import the most appropriate setuptools. This technique is
    necessary to avoid issues such as #315 where setuptools upgrading itself
    would fail to find a function declared in the metadata.
    """
    ...

def run_setup(setup_script, args): # -> None:
    """Run a distutils setup script, sandboxed in its directory"""
    ...

class AbstractSandbox:
    """Wrap 'os' module and 'open()' builtin for virtualizing setup scripts"""
    _active = ...
    def __init__(self) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    
    def run(self, func):
        """Run 'func' under os sandboxing"""
        ...
    
    if _file:
        _file = ...
    _open = ...


if hasattr(os, 'devnull'):
    _EXCEPTIONS = ...
else:
    _EXCEPTIONS = ...
class DirectorySandbox(AbstractSandbox):
    """Restrict operations to a single subdirectory - pseudo-chroot"""
    write_ops = ...
    _exception_patterns = ...
    def __init__(self, sandbox, exceptions=...) -> None:
        ...
    
    if _file:
        ...
    def tmpnam(self): # -> NoReturn:
        ...
    
    def open(self, file, flags, mode=..., *args, **kw):
        """Called for low-level os.open()"""
        ...
    


WRITE_FLAGS = ...
class SandboxViolation(DistutilsError):
    """A setup script attempted to modify the filesystem outside the sandbox"""
    tmpl = ...
    def __str__(self) -> str:
        ...
    


