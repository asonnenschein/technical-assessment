"""
This type stub file was generated by pyright.
"""

from . import _compat as compat

"""
Compatibility shim for the vectorized geometry operations.

Uses PyGEOS if available/set, otherwise loops through Shapely geometries.

"""
_names = ...
if compat.USE_PYGEOS:
    type_mapping = ...
    geometry_type_ids = ...
    geometry_type_values = ...
else:
    ...
def from_shapely(data): # -> ndarray[Unknown, Unknown]:
    """
    Convert a list or array of shapely objects to an object-dtype numpy
    array of validated geometry elements.

    """
    ...

def to_shapely(data): # -> ndarray[Unknown, Unknown]:
    ...

def from_wkb(data): # -> ndarray[Unknown, Unknown]:
    """
    Convert a list or array of WKB objects to a np.ndarray[geoms].
    """
    ...

def to_wkb(data, hex=..., **kwargs): # -> ndarray[Unknown, Unknown]:
    ...

def from_wkt(data): # -> ndarray[Unknown, Unknown]:
    """
    Convert a list or array of WKT objects to a np.ndarray[geoms].
    """
    ...

def to_wkt(data, **kwargs): # -> ndarray[Unknown, Unknown]:
    ...

def points_from_xy(x, y, z=...): # -> ndarray[Unknown, Unknown]:
    ...

def is_valid(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def is_empty(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def is_simple(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def is_ring(data): # -> ndarray[Unknown, Unknown]:
    ...

def is_closed(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def has_z(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def geom_type(data): # -> Any | (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def area(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def length(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def boundary(data):
    ...

def centroid(data):
    ...

def convex_hull(data):
    ...

def envelope(data):
    ...

def exterior(data):
    ...

def interiors(data): # -> ndarray[Unknown, Unknown]:
    ...

def representative_point(data): # -> ndarray[Unknown, Unknown]:
    ...

def covers(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def covered_by(data, other):
    ...

def contains(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def crosses(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def disjoint(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def equals(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def intersects(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def overlaps(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def touches(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def within(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def equals_exact(data, other, tolerance): # -> ndarray[Unknown, Unknown]:
    ...

def almost_equals(self, other, decimal): # -> ndarray[Unknown, Unknown]:
    ...

def difference(data, other):
    ...

def intersection(data, other):
    ...

def symmetric_difference(data, other):
    ...

def union(data, other):
    ...

def distance(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def buffer(data, distance, resolution=..., **kwargs): # -> ndarray[Unknown, Unknown]:
    ...

def interpolate(data, distance, normalized=...): # -> ndarray[Unknown, Unknown]:
    ...

def simplify(data, tolerance, preserve_topology=...): # -> ndarray[Unknown, Unknown]:
    ...

def normalize(data): # -> ndarray[Unknown, Unknown]:
    ...

def project(data, other, normalized=...): # -> ndarray[Unknown, Unknown]:
    ...

def relate(data, other): # -> ndarray[Unknown, Unknown]:
    ...

def unary_union(data): # -> BaseGeometry | None:
    ...

def get_x(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def get_y(data): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
    ...

def get_z(data): # -> ndarray[Unknown, Unknown]:
    ...

def bounds(data): # -> ndarray[Unknown, Unknown]:
    ...

def transform(data, func): # -> ndarray[Unknown, Unknown]:
    ...

