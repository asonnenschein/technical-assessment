"""
This type stub file was generated by pyright.
"""

from pandas.api.extensions import ExtensionArray, ExtensionDtype
from shapely.geometry.base import BaseGeometry

class GeometryDtype(ExtensionDtype):
    type = BaseGeometry
    name = ...
    na_value = ...
    @classmethod
    def construct_from_string(cls, string): # -> GeometryDtype:
        ...
    
    @classmethod
    def construct_array_type(cls): # -> Type[GeometryArray]:
        ...
    


def from_shapely(data, crs=...): # -> GeometryArray:
    """
    Convert a list or array of shapely objects to a GeometryArray.

    Validates the elements.

    Parameters
    ----------
    data : array-like
        list or array of shapely objects
    crs : value, optional
        Coordinate Reference System of the geometry objects. Can be anything accepted by
        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,
        such as an authority string (eg "EPSG:4326") or a WKT string.

    """
    ...

def to_shapely(geoms): # -> ndarray[Unknown, Unknown]:
    """
    Convert GeometryArray to numpy object array of shapely objects.
    """
    ...

def from_wkb(data, crs=...): # -> GeometryArray:
    """
    Convert a list or array of WKB objects to a GeometryArray.

    Parameters
    ----------
    data : array-like
        list or array of WKB objects
    crs : value, optional
        Coordinate Reference System of the geometry objects. Can be anything accepted by
        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,
        such as an authority string (eg "EPSG:4326") or a WKT string.

    """
    ...

def to_wkb(geoms, hex=..., **kwargs): # -> ndarray[Unknown, Unknown]:
    """
    Convert GeometryArray to a numpy object array of WKB objects.
    """
    ...

def from_wkt(data, crs=...): # -> GeometryArray:
    """
    Convert a list or array of WKT objects to a GeometryArray.

    Parameters
    ----------
    data : array-like
        list or array of WKT objects
    crs : value, optional
        Coordinate Reference System of the geometry objects. Can be anything accepted by
        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,
        such as an authority string (eg "EPSG:4326") or a WKT string.

    """
    ...

def to_wkt(geoms, **kwargs): # -> ndarray[Unknown, Unknown]:
    """
    Convert GeometryArray to a numpy object array of WKT objects.
    """
    ...

def points_from_xy(x, y, z=..., crs=...): # -> GeometryArray:
    """
    Generate GeometryArray of shapely Point geometries from x, y(, z) coordinates.

    In case of geographic coordinates, it is assumed that longitude is captured by
    ``x`` coordinates and latitude by ``y``.

    Parameters
    ----------
    x, y, z : iterable
    crs : value, optional
        Coordinate Reference System of the geometry objects. Can be anything accepted by
        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,
        such as an authority string (eg "EPSG:4326") or a WKT string.

    Examples
    --------
    >>> import pandas as pd
    >>> df = pd.DataFrame({'x': [0, 1, 2], 'y': [0, 1, 2], 'z': [0, 1, 2]})
    >>> df
       x  y  z
    0  0  0  0
    1  1  1  1
    2  2  2  2
    >>> geometry = geopandas.points_from_xy(x=[1, 0], y=[0, 1])
    >>> geometry = geopandas.points_from_xy(df['x'], df['y'], df['z'])
    >>> gdf = geopandas.GeoDataFrame(
    ...     df, geometry=geopandas.points_from_xy(df['x'], df['y']))

    Having geographic coordinates:

    >>> df = pd.DataFrame({'longitude': [-140, 0, 123], 'latitude': [-65, 1, 48]})
    >>> df
       longitude  latitude
    0       -140       -65
    1          0         1
    2        123        48
    >>> geometry = geopandas.points_from_xy(df.longitude, df.latitude, crs="EPSG:4326")

    Returns
    -------
    output : GeometryArray
    """
    ...

class GeometryArray(ExtensionArray):
    """
    Class wrapping a numpy array of Shapely objects and
    holding the array-based implementations.
    """
    _dtype = ...
    def __init__(self, data, crs=...) -> None:
        ...
    
    @property
    def sindex(self): # -> PyGEOSSTRTreeIndex | RTreeIndex:
        ...
    
    @property
    def has_sindex(self): # -> bool:
        """Check the existence of the spatial index without generating it.

        Use the `.sindex` attribute on a GeoDataFrame or GeoSeries
        to generate a spatial index if it does not yet exist,
        which may take considerable time based on the underlying index
        implementation.

        Note that the underlying spatial index may not be fully
        initialized until the first use.

        See Also
        ---------
        GeoDataFrame.has_sindex

        Returns
        -------
        bool
            `True` if the spatial index has been generated or
            `False` if not.
        """
        ...
    
    @property
    def crs(self): # -> CRS | None:
        """
        The Coordinate Reference System (CRS) represented as a ``pyproj.CRS``
        object.

        Returns None if the CRS is not set, and to set the value it
        :getter: Returns a ``pyproj.CRS`` or None. When setting, the value
        Coordinate Reference System of the geometry objects. Can be anything accepted by
        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,
        such as an authority string (eg "EPSG:4326") or a WKT string.
        """
        ...
    
    @crs.setter
    def crs(self, value): # -> None:
        """Sets the value of the crs"""
        ...
    
    def check_geographic_crs(self, stacklevel): # -> None:
        """Check CRS and warn if the planar operation is done in a geographic CRS"""
        ...
    
    @property
    def dtype(self): # -> GeometryDtype:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, idx): # -> Any | BaseGeometry | GeometryArray | None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __getstate__(self): # -> tuple[Unknown, CRS | Unknown | None] | Dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    @property
    def is_valid(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def is_empty(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def is_simple(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def is_ring(self): # -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def is_closed(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def has_z(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def geom_type(self): # -> Any | (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def area(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def length(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def boundary(self): # -> GeometryArray:
        ...
    
    @property
    def centroid(self): # -> GeometryArray:
        ...
    
    @property
    def convex_hull(self): # -> GeometryArray:
        ...
    
    @property
    def envelope(self): # -> GeometryArray:
        ...
    
    @property
    def exterior(self): # -> GeometryArray:
        ...
    
    @property
    def interiors(self): # -> ndarray[Unknown, Unknown]:
        ...
    
    def representative_point(self): # -> GeometryArray:
        ...
    
    def covers(self, other): # -> Any:
        ...
    
    def covered_by(self, other): # -> Any:
        ...
    
    def contains(self, other): # -> Any:
        ...
    
    def crosses(self, other): # -> Any:
        ...
    
    def disjoint(self, other): # -> Any:
        ...
    
    def geom_equals(self, other): # -> Any:
        ...
    
    def intersects(self, other): # -> Any:
        ...
    
    def overlaps(self, other): # -> Any:
        ...
    
    def touches(self, other): # -> Any:
        ...
    
    def within(self, other): # -> Any:
        ...
    
    def geom_equals_exact(self, other, tolerance): # -> Any:
        ...
    
    def geom_almost_equals(self, other, decimal): # -> Any:
        ...
    
    def equals_exact(self, other, tolerance): # -> Any:
        ...
    
    def almost_equals(self, other, decimal): # -> Any:
        ...
    
    def difference(self, other): # -> GeometryArray:
        ...
    
    def intersection(self, other): # -> GeometryArray:
        ...
    
    def symmetric_difference(self, other): # -> GeometryArray:
        ...
    
    def union(self, other): # -> GeometryArray:
        ...
    
    def distance(self, other): # -> Any:
        ...
    
    def buffer(self, distance, resolution=..., **kwargs): # -> GeometryArray:
        ...
    
    def interpolate(self, distance, normalized=...): # -> GeometryArray:
        ...
    
    def simplify(self, tolerance, preserve_topology=...): # -> GeometryArray:
        ...
    
    def project(self, other, normalized=...): # -> ndarray[Unknown, Unknown]:
        ...
    
    def relate(self, other): # -> ndarray[Unknown, Unknown]:
        ...
    
    def unary_union(self): # -> BaseGeometry | None:
        ...
    
    def affine_transform(self, matrix): # -> GeometryArray:
        ...
    
    def translate(self, xoff=..., yoff=..., zoff=...): # -> GeometryArray:
        ...
    
    def rotate(self, angle, origin=..., use_radians=...): # -> GeometryArray:
        ...
    
    def scale(self, xfact=..., yfact=..., zfact=..., origin=...): # -> GeometryArray:
        ...
    
    def skew(self, xs=..., ys=..., origin=..., use_radians=...): # -> GeometryArray:
        ...
    
    def to_crs(self, crs=..., epsg=...): # -> GeometryArray:
        """Returns a ``GeometryArray`` with all geometries transformed to a new
        coordinate reference system.

        Transform all geometries in a GeometryArray to a different coordinate
        reference system.  The ``crs`` attribute on the current GeometryArray must
        be set.  Either ``crs`` or ``epsg`` may be specified for output.

        This method will transform all points in all objects.  It has no notion
        or projecting entire geometries.  All segments joining points are
        assumed to be lines in the current projection, not geodesics.  Objects
        crossing the dateline (or other projection boundary) will have
        undesirable behavior.

        Parameters
        ----------
        crs : pyproj.CRS, optional if `epsg` is specified
            The value can be anything accepted
            by :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,
            such as an authority string (eg "EPSG:4326") or a WKT string.
        epsg : int, optional if `crs` is specified
            EPSG code specifying output projection.

        Returns
        -------
        GeometryArray

        Examples
        --------
        >>> from shapely.geometry import Point
        >>> from geopandas.array import from_shapely, to_wkt
        >>> a = from_shapely([Point(1, 1), Point(2, 2), Point(3, 3)], crs=4326)
        >>> to_wkt(a)
        array(['POINT (1 1)', 'POINT (2 2)', 'POINT (3 3)'], dtype=object)
        >>> a.crs  # doctest: +SKIP
        <Geographic 2D CRS: EPSG:4326>
        Name: WGS 84
        Axis Info [ellipsoidal]:
        - Lat[north]: Geodetic latitude (degree)
        - Lon[east]: Geodetic longitude (degree)
        Area of Use:
        - name: World
        - bounds: (-180.0, -90.0, 180.0, 90.0)
        Datum: World Geodetic System 1984
        - Ellipsoid: WGS 84
        - Prime Meridian: Greenwich

        >>> a = a.to_crs(3857)
        >>> to_wkt(a)
        array(['POINT (111319 111325)', 'POINT (222639 222684)',
               'POINT (333958 334111)'], dtype=object)
        >>> a.crs  # doctest: +SKIP
        <Projected CRS: EPSG:3857>
        Name: WGS 84 / Pseudo-Mercator
        Axis Info [cartesian]:
        - X[east]: Easting (metre)
        - Y[north]: Northing (metre)
        Area of Use:
        - name: World - 85째S to 85째N
        - bounds: (-180.0, -85.06, 180.0, 85.06)
        Coordinate Operation:
        - name: Popular Visualisation Pseudo-Mercator
        - method: Popular Visualisation Pseudo Mercator
        Datum: World Geodetic System 1984
        - Ellipsoid: WGS 84
        - Prime Meridian: Greenwich

        """
        ...
    
    def estimate_utm_crs(self, datum_name=...): # -> CRS:
        """Returns the estimated UTM CRS based on the bounds of the dataset.

        .. versionadded:: 0.9

        .. note:: Requires pyproj 3+

        Parameters
        ----------
        datum_name : str, optional
            The name of the datum to use in the query. Default is WGS 84.

        Returns
        -------
        pyproj.CRS

        Examples
        --------
        >>> world = geopandas.read_file(
        ...     geopandas.datasets.get_path("naturalearth_lowres")
        ... )
        >>> germany = world.loc[world.name == "Germany"]
        >>> germany.geometry.values.estimate_utm_crs()  # doctest: +SKIP
        <Projected CRS: EPSG:32632>
        Name: WGS 84 / UTM zone 32N
        Axis Info [cartesian]:
        - E[east]: Easting (metre)
        - N[north]: Northing (metre)
        Area of Use:
        - name: World - N hemisphere - 6째E to 12째E - by country
        - bounds: (6.0, 0.0, 12.0, 84.0)
        Coordinate Operation:
        - name: UTM zone 32N
        - method: Transverse Mercator
        Datum: World Geodetic System 1984
        - Ellipsoid: WGS 84
        - Prime Meridian: Greenwich
        """
        ...
    
    @property
    def x(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        """Return the x location of point geometries in a GeoSeries"""
        ...
    
    @property
    def y(self): # -> (object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray[Unknown, Unknown]:
        """Return the y location of point geometries in a GeoSeries"""
        ...
    
    @property
    def z(self): # -> ndarray[Unknown, Unknown]:
        """Return the z location of point geometries in a GeoSeries"""
        ...
    
    @property
    def bounds(self): # -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def total_bounds(self): # -> ndarray[Unknown, Unknown]:
        ...
    
    @property
    def size(self): # -> int:
        ...
    
    @property
    def shape(self): # -> tuple[Unknown | int]:
        ...
    
    @property
    def ndim(self): # -> int:
        ...
    
    def copy(self, *args, **kwargs): # -> GeometryArray:
        ...
    
    def take(self, indices, allow_fill=..., fill_value=...): # -> GeometryArray:
        ...
    
    def fillna(self, value=..., method=..., limit=...): # -> GeometryArray:
        """Fill NA/NaN values using the specified method.

        Parameters
        ----------
        value : scalar, array-like
            If a scalar value is passed it is used to fill all missing values.
            Alternatively, an array-like 'value' can be given. It's expected
            that the array-like have the same length as 'self'.
        method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None
            Method to use for filling holes in reindexed Series
            pad / ffill: propagate last valid observation forward to next valid
            backfill / bfill: use NEXT valid observation to fill gap
        limit : int, default None
            If method is specified, this is the maximum number of consecutive
            NaN values to forward/backward fill. In other words, if there is
            a gap with more than this number of consecutive NaNs, it will only
            be partially filled. If method is not specified, this is the
            maximum number of entries along the entire axis where NaNs will be
            filled.

        Returns
        -------
        filled : ExtensionArray with NA/NaN filled
        """
        ...
    
    def astype(self, dtype, copy=...): # -> GeometryArray | ABCExtensionArray | ndarray[Unknown, Unknown]:
        """
        Cast to a NumPy array with 'dtype'.

        Parameters
        ----------
        dtype : str or dtype
            Typecode or data-type to which the array is cast.
        copy : bool, default True
            Whether to copy the data, even if not necessary. If False,
            a copy is made only if the old dtype does not match the
            new dtype.

        Returns
        -------
        array : ndarray
            NumPy ndarray with 'dtype' for its dtype.
        """
        ...
    
    def isna(self): # -> ndarray[Unknown, Unknown]:
        """
        Boolean NumPy array indicating if each value is missing
        """
        ...
    
    def unique(self): # -> ndarray[Unknown, Unknown] | Index[Unknown]:
        """Compute the ExtensionArray of unique values.

        Returns
        -------
        uniques : ExtensionArray
        """
        ...
    
    @property
    def nbytes(self): # -> int:
        ...
    
    def shift(self, periods=..., fill_value=...): # -> ABCExtensionArray:
        """
        Shift values by desired number.

        Newly introduced missing values are filled with
        ``self.dtype.na_value``.

        Parameters
        ----------
        periods : int, default 1
            The number of periods to shift. Negative values are allowed
            for shifting backwards.

        fill_value : object, optional (default None)
            The scalar value to use for newly introduced missing values.
            The default is ``self.dtype.na_value``.

        Returns
        -------
        GeometryArray
            Shifted.

        Notes
        -----
        If ``self`` is empty or ``periods`` is 0, a copy of ``self`` is
        returned.

        If ``periods > len(self)``, then an array of size
        len(self) is returned, with all values filled with
        ``self.dtype.na_value``.
        """
        ...
    
    def __array__(self, dtype=...): # -> ndarray[Unknown, Unknown]:
        """
        The numpy array interface.

        Returns
        -------
        values : numpy array
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __contains__(self, item): # -> bool_ | Literal[False]:
        """
        Return for `item in self`.
        """
        ...
    


