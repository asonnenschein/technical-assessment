"""
This type stub file was generated by pyright.
"""

log = ...

class Collection:
    """A file-like interface to features of a vector dataset

    Python text file objects are iterators over lines of a file. Fiona
    Collections are similar iterators (not lists!) over features
    represented as GeoJSON-like mappings.
    """

    def __init__(
        self,
        path,
        mode=...,
        driver=...,
        schema=...,
        crs=...,
        encoding=...,
        layer=...,
        vsi=...,
        archive=...,
        enabled_drivers=...,
        crs_wkt=...,
        ignore_fields=...,
        ignore_geometry=...,
        **kwargs
    ) -> None:
        """The required ``path`` is the absolute or relative path to
        a file, such as '/data/test_uk.shp'. In ``mode`` 'r', data can
        be read only. In ``mode`` 'a', data can be appended to a file.
        In ``mode`` 'w', data overwrites the existing contents of
        a file.

        In ``mode`` 'w', an OGR ``driver`` name and a ``schema`` are
        required. A Proj4 ``crs`` string is recommended. If both ``crs``
        and ``crs_wkt`` keyword arguments are passed, the latter will
        trump the former.

        In 'w' mode, kwargs will be mapped to OGR layer creation
        options.
        """
        ...
    def __repr__(self): ...
    def guard_driver_mode(self): ...
    @property
    def driver(self):  # -> str | None:
        """Returns the name of the proper OGR driver."""
        ...
    @property
    def schema(self):  # -> Unknown | None:
        """Returns a mapping describing the data schema.

        The mapping has 'geometry' and 'properties' items. The former is a
        string such as 'Point' and the latter is an ordered mapping that
        follows the order of fields in the data file.
        """
        ...
    @property
    def crs(self):  # -> None:
        """Returns a Proj4 string."""
        ...
    @property
    def crs_wkt(self):  # -> None:
        """Returns a WKT string."""
        ...
    @property
    def meta(self):  # -> dict[str, Unknown | str | None]:
        """Returns a mapping with the driver, schema, crs, and additional
        properties."""
        ...
    profile = ...
    def filter(self, *args, **kwds):
        """Returns an iterator over records, but filtered by a test for
        spatial intersection with the provided ``bbox``, a (minx, miny,
        maxx, maxy) tuple or a geometry ``mask``.

        Positional arguments ``stop`` or ``start, stop[, step]`` allows
        iteration to skip over items or stop at a specific item.

        Note: spatial filtering using ``mask`` may be inaccurate and returning
        all features overlapping the envelope of ``mask``.

        """
        ...
    def items(self, *args, **kwds):
        """Returns an iterator over FID, record pairs, optionally
        filtered by a test for spatial intersection with the provided
        ``bbox``, a (minx, miny, maxx, maxy) tuple or a geometry
        ``mask``.

        Positional arguments ``stop`` or ``start, stop[, step]`` allows
        iteration to skip over items or stop at a specific item.

        Note: spatial filtering using ``mask`` may be inaccurate and returning
        all features overlapping the envelope of ``mask``.

        """
        ...
    def keys(self, *args, **kwds):
        """Returns an iterator over FIDs, optionally
        filtered by a test for spatial intersection with the provided
        ``bbox``, a (minx, miny, maxx, maxy) tuple or a geometry
        ``mask``.

        Positional arguments ``stop`` or ``start, stop[, step]`` allows
        iteration to skip over items or stop at a specific item.

        Note: spatial filtering using ``mask`` may be inaccurate and returning
        all features overlapping the envelope of ``mask``.
        """
        ...
    def __contains__(self, fid): ...
    values = ...
    def __iter__(self):
        """Returns an iterator over records."""
        ...
    def __next__(self):
        """Returns next record from iterator."""
        ...
    next = ...
    def __getitem__(self, item): ...
    def get(self, item): ...
    def writerecords(self, records):  # -> None:
        """Stages multiple records for writing to disk."""
        ...
    def write(self, record):  # -> None:
        """Stages a record for writing to disk."""
        ...
    def validate_record(self, record):  # -> Literal[False]:
        """Compares the record to the collection's schema.

        Returns ``True`` if the record matches, else ``False``.
        """
        ...
    def validate_record_geometry(self, record):
        """Compares the record's geometry to the collection's schema.

        Returns ``True`` if the record matches, else ``False``.
        """
        ...
    def __len__(self): ...
    @property
    def bounds(self):  # -> None:
        """Returns (minx, miny, maxx, maxy)."""
        ...
    def flush(self):  # -> None:
        """Flush the buffer."""
        ...
    def close(self):  # -> None:
        """In append or write mode, flushes data to disk, then ends
        access."""
        ...
    @property
    def closed(self):  # -> bool:
        """``False`` if data can be accessed, otherwise ``True``."""
        ...
    def __enter__(self): ...
    def __exit__(self, type, value, traceback): ...
    def __del__(self): ...

ALL_GEOMETRY_TYPES = ...

def get_filetype(bytesbuf):  # -> Literal['zip', '']:
    """Detect compression type of bytesbuf.

    ZIP only. TODO: add others relevant to GDAL/OGR."""
    ...

class BytesCollection(Collection):
    """BytesCollection takes a buffer of bytes and maps that to
    a virtual file that can then be opened by fiona.
    """

    def __init__(self, bytesbuf, **kwds) -> None:
        """Takes buffer of bytes whose contents is something we'd like
        to open with Fiona and maps it to a virtual file.
        """
        ...
    def close(self):  # -> None:
        """Removes the virtual file associated with the class."""
        ...
    def __repr__(self): ...
